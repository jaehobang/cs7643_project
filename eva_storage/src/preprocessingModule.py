"""
This module performs the preprocessing step.
Performs basic computer vision techniques and background subtraction for preparing the inputs of the network
If any issues arise please contact jaeho.bang@gmail.com

@Jaeho Bang

"""

import numpy as np
import cv2
import os
import config
from loaders.uadetrac_loader import UADetracLoader

TIMED = True


class PreprocessingModule:

    def __init__(self):
        self.images = None
        self.video_start_indexes = None
        self.segmented_images = None

    def run(self, images:np.ndarray, video_start_indices:list):
        """
        Try loading the data
        If there is nothing to load, we have to manually go through the process

        :param images:
        :param video_start_indices:
        :return:
        """
        self._loadSegmentedImages()

        if self.segmented_images is None:

            # fgbg only takes grayscale images, we need to convert
            images_gray = np.mean(images, axis = 3)

            segmented_images = np.ndarray(shape = images_gray.shape, dtype = np.uint8)
            for i in range(len(video_start_indices)):
                # start index is inclusive, end index is not inclusive
                start_index = video_start_indices[i]
                if i == len(video_start_indices) - 1:
                    end_index = images_gray.shape[0]
                else:
                    end_index = video_start_indices[i + 1]
                fgbg = cv2.createBackgroundSubtractorKNN(detectShadows = True)

                # first round is to tune the values of the background subtractor
                for ii in range(start_index, end_index):
                    fgbg.apply(images_gray[ii])

                # second round is to extract the masked values
                for ii in range(start_index, end_index):
                    segmented_images[ii] = fgbg.apply(images_gray[ii])

            self.segmented_images = self._postfgbg(segmented_images)

        return self.segmented_images

    def _postfgbg(self, segmented_images:np.ndarray):
        """
        Performs cv functions on outputs of background subtraction algorithms
        :param segmented_images: images generated by background subtraction algorithms
        :return: cv applied segmentation images
        """
        ## tmp_data must be grayscale!
        if segmented_images.ndim > 3:
            print("tmp_data must be grayscale!!")
            print("  current dimension is", segmented_images.shape)
            raise ValueError


        new_segmented_images = np.ndarray(shape = segmented_images.shape)
        kernel = np.ones((3,3), np.uint8)

        for i in range(segmented_images.shape[0]):
            blur = cv2.GaussianBlur(segmented_images[i], (3,3), 0)
            opening = cv2.morphologyEx(blur, cv2.MORPH_OPEN, kernel, iterations = 1)
            opening = opening.astype(np.uint8)
            ret, thresh = cv2.threshold(opening, 0, 255, cv2.THRESH_OTSU)
            new_segmented_images[i] = thresh

        new_segmented_images = new_segmented_images.astype(np.uint8)
        return new_segmented_images


    def saveSegmentedImages(self, overwrite = False):
        eva_dir = config.eva_dir
        dir = os.path.join(eva_dir, 'eva_storage', 'tmp_data', 'segmented_images.npy')
        if self.segmented_images is None:
            print("Must apply the background subtraction algorithm first")
            return
        elif os.path.exists(dir) and overwrite == False:
            print("Already saved segmented image file exists.. to overwrite, make sure the overwrite option is True")
        else:
            np.save(dir, self.segmented_images)


    def _loadSegmentedImages(self):
        eva_dir = config.eva_dir
        dir = os.path.join(eva_dir, 'eva_storage', 'tmp_data', 'segmented_images.npy')
        if os.path.exists(dir):
            self.segmented_images = np.load(dir)
        else:
            print("path", dir, "does not exist..")











if __name__ == "__main__":
    loader = UADetracLoader()
    images = loader.load_images()
    labels = loader.load_labels()
    boxes = loader.load_boxes()
    video_start_indices = loader.get_video_start_indices()
    #images loaded as 300x300 - prepare the images
    preprocessor = PreprocessingModule()
    segmented_images = preprocessor.run(images, video_start_indices)



